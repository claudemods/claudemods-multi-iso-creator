#include <iostream>

#include <string>

#include <vector>

#include <filesystem>

#include <cstdlib>

#include <stdexcept>

#include <unistd.h>

#include <sys/wait.h>

#include <chrono>

#include <iomanip>

#include <sstream>

#include <fcntl.h>

#include <poll.h>

#include <thread>

#include <mutex>

#include <condition_variable>


namespace fs = std::filesystem;


const std::string PASSWORD = "payday101claudemods101payday101claudemodspayday";


void print_banner() {

    std::string version_message = "Claudemods SquashFS Creator v1.04 This Could Take a While!";


    std::cout << "\033[31m" << R"(

░█████╗░██╗░░░░░░█████╗░██╗░░░██╗██████╗░███████╗███╗░░░███╗░█████╗░██████╗░░██████╗

██╔══██╗██║░░░░░██╔══██╗██║░░░██║██╔══██╗██╔════╝████╗░████║██╔══██╗██╔══██╗██╔════╝

██║░░╚═╝██║░░░░░███████║██║░░░██║██║░░██║█████╗░░██╔████╔██║██║░░██║██║░░██║╚█████╗░

██║░░██╗██║░░░░░██╔══██║██║░░░██║██║░░██║██╔══╝░░██║╚██╔╝██║██║░░██║██║░░██║░╚═══██╗

╚█████╔╝███████╗██║░░██║╚██████╔╝██████╔╝███████╗██║░╚═╝░██║╚█████╔╝██████╔╝██████╔╝

░╚════╝░╚══════╝╚═╝░░░░░░╚═════╝░╚═════╝░╚══════╝╚═╝░░░░░╚═╝░▚════╝░╚═════╝░╚═════╝░

)" << "\033[0m" << std::endl;


std::cout << "\033[34m" << version_message << "\033[0m" << std::endl;


// Display date and time

auto now = std::chrono::system_clock::now();

auto now_time_t = std::chrono::system_clock::to_time_t(now);

std::tm now_tm = *std::localtime(&now_time_t);

std::cout << "\033[32mDate and Time: " << std::put_time(&now_tm, "%Y-%m-%d %H:%M:%S") << "\033[0m" << std::endl;


// Display system size and available size

std::string df_output = "";

FILE* pipe = popen("df -h /", "r");

if (pipe) {

    char buffer[128];

    while (!feof(pipe)) {

        if (fgets(buffer, 128, pipe) != nullptr)

            df_output += buffer;

    }

    pclose(pipe);

}


std::istringstream df_stream(df_output);

std::string line;

std::vector<std::string> info;

while (std::getline(df_stream, line)) {

    info.push_back(line);

}


if (info.size() > 1) {

    std::istringstream info_stream(info.back());

    std::string token;

    std::vector<std::string> tokens;

    while (info_stream >> token) {

        tokens.push_back(token);

    }


    if (tokens.size() >= 4) {

        std::cout << "\033[32mUsed System Space: " << tokens[2] << "\033[0m" << std::endl;

        std::cout << "\033[32mAvailable System Space: " << tokens[3] << "\033[0m" << std::endl;

    }

}

}


void run_command(const std::vector<std::string>& command, bool is_squashfs = false) {

    std::string cmd = command[0];

    for (size_t i = 1; i < command.size(); ++i) {

        cmd += " " + command[i];

    }


    FILE* pipe = popen(cmd.c_str(), "r");

    if (!pipe) {

        throw std::runtime_error("popen failed");

    }


    char buffer[128];

    while (fgets(buffer, sizeof(buffer), pipe) != nullptr) {

        if (is_squashfs) {

            std::cout << "\033[34m" << buffer << "\033[0m";

        } else {

            std::cout << buffer;

        }

        std::cout.flush(); // Ensure the output is immediately flushed to the console

    }


    int status = pclose(pipe);

    if (status != 0) {

        throw std::runtime_error("Command failed with status " + std::to_string(status));

    }

}


void create_squashfs_image(const std::string& output_image, const std::string& clone_dir, const std::vector<std::string>& exclude_dirs, const std::string& compression) {

    std::vector<std::string> command = {"sudo", "mksquashfs", clone_dir, output_image,

        "-comp", compression, "-b", "1M",

        "-no-duplicates", "-no-recovery", "-always-use-fragments",

        "-wildcards", "-xattrs"};


        if (compression == "xz") {

            command.push_back("-Xbcj");

            command.push_back("x86");

        }


        for (const auto& dir : exclude_dirs) {

            // Remove leading slashes to make the paths relative

            std::string relative_dir = dir;

            while (relative_dir.front() == '/') {

                relative_dir.erase(relative_dir.begin());

            }

            command.push_back("-e");

            command.push_back(relative_dir);

        }


        std::cout << "\033[32mCreating SquashFS image: " << fs::path(output_image).filename() << "\033[0m" << std::endl;

        run_command(command, true); // Pass true to indicate this is a SquashFS command

}


void clone_system(const std::string& clone_dir, const std::vector<std::string>& exclude_dirs) {

    if (fs::exists(clone_dir)) {

        std::cout << "\033[32mSkipping removal of existing clone directory: " << clone_dir << "\033[0m" << std::endl;

    } else {

        fs::create_directories(clone_dir);

    }


    std::vector<std::string> command = {"sudo", "rsync", "-aHAX", "--numeric-ids", "--info=progress2",

        "--include", "dev", "--include", "proc", "--include", "tmp", "--include", "sys",

        "--include", "run", // Include the /run directory

        "--include", "lib/modules", // Include the /lib/modules directory

        "--exclude", "dev/*", "--exclude", "proc/*", "--exclude", "tmp/*", "--exclude", "sys/*",

        "--exclude", "run/*"}; // Exclude the contents of /run directory


        for (const auto& dir : exclude_dirs) {

            // Remove leading slashes to make the paths relative

            std::string relative_dir = dir;

            while (relative_dir.front() == '/') {

                relative_dir.erase(relative_dir.begin());

            }

            command.push_back("--exclude");

            command.push_back(relative_dir);

        }

        command.push_back("/");

        command.push_back(clone_dir);

        std::cout << "\033[32mCloning system directory to: " << clone_dir << "\033[0m" << std::endl;

        run_command(command);

}


void delete_clone_system_temp(const std::string& clone_dir, const std::string& squashfs_image) {

    std::vector<std::string> command = {"sudo", "rm", "-rf", clone_dir};

    std::cout << "\033[32mDeleting temporary clone directory: " << clone_dir << "\033[0m" << std::endl;

    run_command(command);


    if (fs::exists(squashfs_image)) {

        command = {"sudo", "rm", "-f", squashfs_image};

        std::cout << "\033[32mDeleting SquashFS image: " << squashfs_image << "\033[0m" << std::endl;

        run_command(command);

    } else {

        std::cout << "\033[32mSquashFS image does not exist: " << squashfs_image << "\033[0m" << std::endl;

    }

}


void prompt_to_exit() {

    std::cout << "\033[32mSquashFS image creation completed. Press Enter to exit...\033[0m" << std::endl;

    std::cin.ignore();

    std::cin.get();

}


int main(int argc, char* argv[]) {

    if (argc < 2) {

        std::cerr << "\033[31mUsage: " << argv[0] << " <password>\033[0m" << std::endl;

        return 1;

    }


    std::string provided_password = argv[1];

    if (provided_password != PASSWORD) {

        std::cerr << "\033[31mIncorrect password. Access denied.\033[0m" << std::endl;

        return 1;

    }


    try {

        print_banner();


        fs::path script_dir = fs::current_path();

        fs::path build_dir = "/opt/claudemods-iso-konsole-script/Supported-Distros/Arch/build-image-arch/arch/x86_64";

        fs::create_directories(build_dir);


        std::string squashfs_image = (build_dir / "airootfs.sfs").string();


        std::vector<std::string> exclude_dirs = {

            "var/lib/docker", "cloned_system_temp", "etc/fstab", "etc/mtab",

            "etc/udev/rules.d/70-persistent-cd.rules", "etc/udev/rules.d/70-persistent-net.rules"

        };


        std::string clone_dir = (script_dir / "cloned_system_temp").string();

        std::cout << "\033[32mTemporary clone directory: " << clone_dir << "\033[0m" << std::endl;


        // Ensure the cloned_system_temp directory exists

        if (!fs::exists(clone_dir)) {

            fs::create_directories(clone_dir);

        }


        std::cout << "\033[34mSelect an option:\033[0m" << std::endl;

        std::cout << "\033[34m1. Light compression (lzo)\033[0m" << std::endl;

        std::cout << "\033[34m2. Medium compression (lz4)\033[0m" << std::endl;

        std::cout << "\033[34m3. Max compression (xz)\033[0m" << std::endl;

        std::cout << "\033[34m4. Create SquashFS from clone_system_temp\033[0m" << std::endl;

        std::cout << "\033[34m5. Delete clone_system_temp and SquashFS image\033[0m" << std::endl;

        int choice;

        std::cin >> choice;


        std::string compression;

        switch (choice) {

            case 1:

                compression = "lzo";

                break;

            case 2:

                compression = "lz4";

                break;

            case 3:

                compression = "xz";

                break;

            case 4:

                std::cout << "\033[34mCreating SquashFS from clone_system_temp\033[0m" << std::endl;

                std::cout << "\033[34mSelect compression level for SquashFS:\033[0m" << std::endl;

                std::cout << "\033[34m1. Light compression (lzo)\033[0m" << std::endl;

                std::cout << "\033[34m2. Medium compression (lz4)\033[0m" << std::endl;

                std::cout << "\033[34m3. Max compression (xz)\033[0m" << std::endl;

                int squashfs_choice;

                std::cin >> squashfs_choice;

                switch (squashfs_choice) {

                    case 1:

                        compression = "lzo";

                        break;

                    case 2:

                        compression = "lz4";

                        break;

                    case 3:

                        compression = "xz";

                        break;

                    default:

                        std::cerr << "\033[31mInvalid choice. Exiting.\033[0m" << std::endl;

                        return 1;

                }


                create_squashfs_image(squashfs_image, clone_dir, exclude_dirs, compression);

                std::cout << "\033[32mSquashFS image created from cloned_system_temp\033[0m" << std::endl;

                prompt_to_exit();

                return 0;

                    case 5:

                        delete_clone_system_temp(clone_dir, squashfs_image);

                        std::cout << "\033[32mcloned_system_temp directory and SquashFS image deleted\033[0m" << std::endl;

                        prompt_to_exit();

                        return 0;

                    default:

                        std::cerr << "\033[31mInvalid choice. Exiting.\033[0m" << std::endl;

                        return 1;

        }


        clone_system(clone_dir, exclude_dirs);


        create_squashfs_image(squashfs_image, clone_dir, exclude_dirs, compression);


        // Do not delete the clone_system_temp directory

        // std::cout << "\033[32mRemoving temporary clone directory: " << clone_dir << "\033[0m" << std::endl;

        // fs::remove_all(clone_dir);


        prompt_to_exit();

    } catch (const std::exception& e) {

        std::cerr << "\033[31mError: " << e.what() << "\033[0m" << std::endl;

        return 1;

    }


    return 0;

}
